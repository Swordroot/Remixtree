<html>
<head>
  <link href="/css/bootstrap-theme.min.css" rel="stylesheet">
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <script src="/javascript/jquery-3.1.1.min.js"></script>
  <script src="/javascript/bootstrap.min.js"></script>
  <script src="/javascript/d3.min.js"></script>
  <script src="/javascript/createjs.min.js"></script>
</head>
<body>
<script>
    var width = 760;
    var height = 450;
 
    var svg = d3.select("body").append("svg")
    .attr("width", width)
    .attr("height", height)
    .attr("transform","translate(50,50)");//ここがツリーの左上になる。
 
    var tree = d3.tree()
    .size([400,400]) // .size()でツリー全体のサイズを決める。
    .children(children); // children()で入れ子のための名前を指定する。
 
    function children(d) {
      return d["種類"];
    }
 
    d3.json("kinoko_takenoko.json", function(data) {
 
    // tree.nodesで、childrenのname分だけ、name/children/parent/depth/x/yを作る。
    var nodes = tree.nodes(data);
 
    // nodesから、diagonal用データ構造を作る　＝　[{ source:{x:10,y:20}, target:{x:100,y:200} }]など
    var links = tree.links(nodes);
 
    // 円とテキストを入れるノードのコンテナg。
    var node = svg.selectAll(".node")
    .data(nodes) //nodesの数分gを作る。
    .enter()
    .append("g")
    .attr("class","node")
    .attr("transform", function(d){ return "translate("+ d.y + "," + d.x + ")";}); //ノードの場所まで移動。横向きにするためにxとyを逆に。
 
    node.append("circle")
    .attr("r", 4)
    .attr("fill","steelblue");
 
    node.append("text")
    .text(function(d) { return d.name})
    .attr("y",-5);
 
    var diagonal = d3.svg.diagonal()
    .projection(function(d){ return [d.y,d.x];}); // 横向きにするためにxとyを逆に。
 
    //linksで作ったsource、targetでdiagonal曲線を作る。
    svg.selectAll(".link")
    .data(links)
    .enter()
    .append("path")
    .attr("class","link")
    .attr("fill", "none")
    .attr("stroke", "red")
    .attr("d",diagonal);
 
    });
 
/*
var canvas = document.querySelector("canvas"),
    context = canvas.getContext("2d"),
    width = canvas.width,
    height = canvas.height;

var simulation = d3.forceSimulation()
    .force("link", d3.forceLink().id(function(d) { return d.id; }))
    .force("charge", d3.forceManyBody())
    .force("center", d3.forceCenter(width / 2, height / 2));

d3.json("miserables.json", function(error, graph) {
  if (error) throw error;

  simulation
      .nodes(graph.nodes)
      .on("tick", ticked);

  simulation.force("link")
      .links(graph.links);

  d3.select(canvas)
      .call(d3.drag()
          .container(canvas)
          .subject(dragsubject)
          .on("start", jumpTo));
//          .on("start", dragstarted)
//          .on("drag", dragged)
//          .on("end", dragended));

  function ticked() {
    context.clearRect(0, 0, width, height);

    context.beginPath();
    graph.links.forEach(drawLink);
    context.strokeStyle = "#999";
    context.stroke();

    context.beginPath();
    graph.nodes.forEach(drawNode);
    context.fill();
    context.strokeStyle = "#fff";
    context.stroke();
  }

  function dragsubject() {
    return simulation.find(d3.event.x, d3.event.y);
  }
});

function dragstarted() {
  if (!d3.event.active) simulation.alphaTarget(0.3).restart();
  d3.event.subject.fx = d3.event.subject.x;
  d3.event.subject.fy = d3.event.subject.y;
}

function dragged() {
  d3.event.subject.fx = d3.event.x;
  d3.event.subject.fy = d3.event.y;
}

function dragended() {
  if (!d3.event.active) simulation.alphaTarget(0);
  d3.event.subject.fx = null;
  d3.event.subject.fy = null;
}

function drawLink(d) {
  context.moveTo(d.source.x, d.source.y);
  context.lineTo(d.target.x, d.target.y);
}

function drawNode(d) {
  var img = new Image();
  img.src = d.image;
  context.moveTo(d.x + 3, d.y);
  context.drawImage(img, d.x, d.y);
  //context.arc(d.x, d.y, 3, 0, 2 * Math.PI);
}

function jumpTo(){
  location.href = "/tree/play";
}
*/

</script>
</body>
</html>